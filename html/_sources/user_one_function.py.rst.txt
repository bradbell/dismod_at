.. _user_one_function.py-name:

!!!!!!!!!!!!!!!!!!!!
user_one_function.py
!!!!!!!!!!!!!!!!!!!!

xrst input file: ``example/user/one_function.py``

.. meta::
   :keywords: user_one_function.py, fitting, one, function, of, two, variables

.. index:: user_one_function.py, fitting, one, function, of, two, variables

.. _user_one_function.py-title:

Fitting One Function of Two Variables
#####################################

.. meta::
   :keywords: purpose

.. index:: purpose

.. _user_one_function.py@Purpose:

Purpose
*******
This example shows how to fit one function of two variables given
direct measurements of the function.
For our example, we are give measurements of prevalence,
as a function of age and time, and fit a function to the measurements.

.. meta::
   :keywords: rho

.. index:: rho

.. _user_one_function.py@rho:

rho
***
We use *rho*
as a surrogate for prevalence because our model for prevalence
does not use *rho* (we could have used any other rate
and its corresponding integrand).

.. meta::
   :keywords: random, effects

.. index:: random, effects

.. _user_one_function.py@Random Effects:

Random Effects
**************
To keep this example simple, there is only one node ``world``
in the :ref:`node_table-name` , and the
:ref:`mulcov_table@subgroup_smooth_id`
is null in the mulcov_table.
Hence, there are not random effects in this example.

.. meta::
   :keywords: covariates

.. index:: covariates

.. _user_one_function.py@Covariates:

Covariates
**********
Income is the only covariate for this example and it has been normalized
to be between zero and one.  The income reference value corresponds to
no effect. The income multiplier is the true value used to simulate the
data.

.. literalinclude:: ../../example/user/one_function.py
   :lines: 44-46
   :language: py

The *income_mulcov_type* can be either ``"meas_value"`` or
``"rate_value"`` .
It should not make a difference in the results which
:ref:`mulcov_table@mulcov_type` is used because
there is only one rate (one function) being fit, and the
:ref:`integrand_table@integrand_name@ODE` is not needed to compute
the integrand.
You can test this by changing *income_mulcov_type* to
``"rate_value"``
and uses the same :ref:`user_one_function.py@random_seed` .

.. meta::
   :keywords: simulated, data

.. index:: simulated, data

.. _user_one_function.py@Simulated Data:

Simulated Data
**************

.. meta::
   :keywords: data, density

.. index:: data, density

.. _user_one_function.py@Simulated Data@Data Density:

Data Density
============
A direct measurement of *rho*
(which we are using to represent prevalence) corresponds to the
:ref:`remission integrand<avg_integrand@Integrand, I_i(a,t)@remission>` .
We use a :ref:`density_table@density_name@log_gaussian`
model with the following parameters:

.. literalinclude:: ../../example/user/one_function.py
   :lines: 72-73
   :language: py

.. meta::
   :keywords: true, prevalence

.. index:: true, prevalence

.. _user_one_function.py@Simulated Data@True Prevalence:

True Prevalence
===============
For simulating our prevalence data we consider the case where
all the rates are constant and *rho* , *chi* are zero; i.e.,
the differential equation is

.. math::
 :nowrap:

 \begin{eqnarray}
 S'(a) = -( \iota + \omega ) S(a)
 \\
 C'(a) = + \iota S(a) - \omega C(a)
 \end{eqnarray}

where :math:`S(0) = 1` and :math:`C(0) = 0`.
It follows that

.. math::

 S(a) = \exp[ - ( \iota + \omega ) a ]

.. math::

 C(a)
 = \int_0^a \exp[ \omega (s - a) ] \iota S(s) ds

You can check the formula for :math:`C(a)` as follows:
differentiating w.r.t. :math:`a` inside the integral yields
:math:`- \omega C(a)` and differentiating the upper limit
w.r.t. :math:`a` yields :math:`\iota S(a)`.
It follows that

.. math::

 C(a) = \iota \int_0^a \exp[ \omega (s - a) - ( \iota + \omega) s ] ds

.. math::

 C(a) = \iota \exp( - \omega a) \int_0^a \exp( - \iota s ) ds

.. math::

 C(a) = \exp( - \omega a) - \exp[ - ( \iota + \omega) a ]

.. literalinclude:: ../../example/user/one_function.py
   :lines: 124-132
   :language: py

.. meta::
   :keywords: computing, delta

.. index:: computing, delta

.. _user_one_function.py@Computing Delta:

Computing Delta
***************
Once we have simulated a measurement value,
we can solve for :math:`\Delta` are follows; see
:ref:`sigma<data_like@Notation@Transformed Standard Deviation, sigma_i>` :

.. math::

 \sigma = \log( y + \eta + \Delta ) - \log(y + \eta )

.. math::

 \exp ( \sigma ) = \frac{ y + \eta + \Delta }{ y + \eta }

.. math::

 \exp ( \sigma ) ( y + \eta ) = y + \eta + \Delta

.. math::

 \Delta = [ \exp ( \sigma ) - 1 ] ( y + \eta )

For this case there are no measurement noise covariates so
:math:`\sigma` is the standard deviation for the simulated data.
Furthermore, the
:ref:`option_table@minimum_meas_cv` is zero,
so :math:`\Delta` is the *meas_std* .

.. meta::
   :keywords: prevalence, prior

.. index:: prevalence, prior

.. _user_one_function.py@Prevalence Prior:

Prevalence Prior
****************
Prevalence must always be between zero and one so this limits are used
in the prior for prevalence.
Some functions might allow for negative values and the lower limit
for the rate would be negative in that case.

.. meta::
   :keywords: random_seed

.. index:: random_seed

.. _user_one_function.py@random_seed:

random_seed
***********
We use the clock to choose a seed for the random number generator.
If an error occurs, the seed will be printed so that the error can be
reproduced. You can also use a fixed value for the random seed to see
how changing other parameters changes the results.

.. literalinclude:: ../../example/user/one_function.py
   :lines: 179-180
   :language: py

.. meta::
   :keywords: source, code

.. index:: source, code

.. _user_one_function.py@Source Code:

Source Code
***********

.. literalinclude:: ../../example/user/one_function.py
   :lines: 196-440
   :language: py
