lines 5-89 of file: example/user/plot_rate_fit.py

# {xrst_begin user_plot_rate_fit.py}
# {xrst_comment_ch #}
#
# Example Plotting The Rates for a Fit
# ####################################
#
# Nodes
# *****
# There are four nodes in this example.
# The world node has one child, north_america.
# The north_america node has two children, united_states and canada.
# The :ref:`parent_node<option_table@Parent Node>` is canada which
# does not have any children.
#
# Rates
# *****
# There is a parent smoothing the *iota* , *rho*
# and *chi* rates.
# There is no child node smoothing so there are no random effects
# for these rates.
# In addition, there is no parent smoothing for the other rates
# so they are zero.
# The value priors for the rate smoothing is uniform with lower limit 1e-4
# and upper limit 1.0. The mean 0.1, is only used as a starting point
# for the optimization.
# The age and time difference prior for this smoothing is
# uniform with mean zero and no upper or lower bound.
#
# Integrands
# **********
# The integrands for this example are
# :ref:`avg_integrand@Integrand, I_i(a,t)@Sincidence` ,
# :ref:`avg_integrand@Integrand, I_i(a,t)@remission` , and
# :ref:`avg_integrand@Integrand, I_i(a,t)@mtexcess` .
# Note that these integrands are direct measurements of the following rates:
# {xrst_spell_off}
# {xrst_code py}
integrand2rate = {
   'Sincidence':  'iota'   ,
   'remission':   'rho'    ,
   'mtexcess':    'chi'    ,
}
# {xrst_code}
# {xrst_spell_on}
#
# Data
# ****
# All of the data corresponds to canada.
# There is one data point for each of the integrands listed above.
# It is simulated using true value for the corresponding rate:
# {xrst_spell_off}
# {xrst_code py}
def rate_true(rate_name, age, time) :
   age_fraction  = age / 100.0
   time_fraction = (time - 1980) / 40.0
   assert 0 <= age_fraction and age_fraction <= 1.0
   assert 0 <= time_fraction and time_fraction <= 1.0
   value         = age_fraction + time_fraction + 1.0
   factor        = { 'iota':1e-2 , 'rho':5e-2 , 'chi':1e-3  }
   return factor[rate_name] * value
# {xrst_code}
# {xrst_spell_on}
# Even though there is not noise in the simulated data, it is modeled as
# have the following coefficient of variation:
# {xrst_spell_off}
# {xrst_code py}
meas_cv = 0.2
# {xrst_code}
# {xrst_spell_on}
#
# Call to plot_rate_fit
# *********************
# {xrst_literal
#     BEGIN call plot_rate_fit
#     END call plot_rate_fit
# }
#
# Source Code
# ***********
# {xrst_literal
#     BEGIN PYTHON
#     END PYTHON
# }
#
# {xrst_end user_plot_rate_fit.py}
