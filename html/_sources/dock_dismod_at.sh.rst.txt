lines 6-282 of file: bin/dock_dismod_at.sh

# {xrst_begin dock_dismod_at.sh}
# {xrst_spell
#     busybox
#     dockerfile
#     get get
#     podman
#     ps
#     rm
#     rmi
# }
# {xrst_comment_ch #}
#
# Install and Run dismod_at in a Docker Image
# ###########################################
#
# Syntax
# ******
#
# | ./ ``dock_dismod_at.sh image base``
# | ./ ``dock_dismod_at.sh image mixed``
# | ./ ``dock_dismod_at.sh image dismod_at``
# | ./ ``dock_dismod_at.sh image at_cascade``
# | ./ ``dock_dismod_at.sh`` *build_type* *database* *command*  ...
#
# OCI
# ***
# Both docker and podman create Open Container Initiative
# `OCI <https://opencontainers.org/>`_ images and containers.
#
# driver
# ======
# The *driver* program, determined by this setting, can be either
# docker or podman:
# {xrst_spell_off}
# {xrst_code sh}
   driver='podman'
# {xrst_code}
# {xrst_spell_on}
# Below we referee to the value of this shell variable as *driver* .
#
# Logging Output
# **************
# You can save the output of any of the commands above by redirecting
# standard output and standard error to a file.
# For example,
#
#     ./ ``dock_dismod_at.sh image base >&`` *log_file*
#
# will redirect standard output and standard error to *log_file* .
# If you do this, you will not see the progress during execution.
# If also want to monitor the progress, in another window use
#
#     ``tail -f`` *log_file*
#
# This ``tail`` command will not terminate until you enter
# control-C in the window where it is running.
#
# Purpose
# *******
# This bash script will create or run a dismod_at OCI image
# and can be run from any directory.
# Using this script is an  alternative to going through the steps required to
# :ref:`install_dismod_at<install_unix-name>` .
# You can use the following link to get a get a copy of the dismod_at.sh
# `bash script <https://raw.githubusercontent.com/bradbell/dismod_at/master/bin/dock_dismod_at.sh>`_
# If you understand docker, this script also serves as an example
# install of dismod_at.
#
# Requirements
# ************
# You must have a copy of `docker <https://docs.docker.com/>`_, or
# `podman <https://podman.io>`_
# installed on your system.
# You can test this on your system by trying to execute the following command:
#
#     *driver* ``run busybox echo`` ``'Hello World'``
#
# Building Images
# ***************
# The image commands will not execute if the corresponding OCI image
# already exists.
# You must remove containers that use an image and then remove the image,
# before you can execute the image command successfully.
#
# dismod_at_version
# =================
# This script will build the following version of dismod_at image:
# {xrst_spell_off}
# {xrst_code sh}
   dismod_at_version='20221218'
   dismod_at_hash='8fe88d91c49b71160170177be669582370a324de'
# {xrst_code}
# {xrst_spell_on}
#
# at_cascade_version
# ==================
# This script can build the following version of the optional at_cascade image:
# {xrst_spell_off}
# {xrst_code sh}
   at_cascade_version='2022.12.19'
   at_cascade_hash='250be52d0f6fff070e6b79913da221346e0ca68c'
# {xrst_code}
# {xrst_spell_on}
#
# dismod_at.base
# ==============
# The ``image base`` syntax creates a new OCI image with the name
# ``dismod_at.base`` .
# The :ref:`whats_new<whats_new_2019-name>` instructions will tell you if
# you need to re-execute this command.
#
# dismod_at.mixed
# ===============
# The ``image mixed`` syntax creates a new OCI image with the name
# ``dismod_at.mixed`` .
# The ``dismod_at.base`` image must exist before the
# ``dismod_at.mixed`` image can be created.
# The :ref:`whats_new<whats_new_2019-name>` instructions will tell you if
# you need to re-execute this command.
#
# dismod_at.image
# ===============
# The ``image dismod_at`` syntax creates a new OCI image with the name
# ``dismod_at.image`` .
# The ``dismod_at.mixed`` image must exist before the
# ``dismod_at.image`` image can be created.
#
# at_cascade.image
# ================
# The ``image at_cascade`` syntax creates a new OCI image with the name
# ``at_cascade.image`` .
# The ``dismod_at.image`` image must exist before the
# ``at_cascade.image`` image can be created.
# The `at_cascade <https://bradbell.github.io/at_cascade/doc/rst/at_cascade.html>`_ package is an optional add-on to the dismod_at program.
#
# Removing Containers
# ===================
# If an existing container uses an image that is being created,
# you will be prompted with the corresponding *container_id* .
# The command
#
#     *driver* ``rm`` *container_id*
#
# will remove the container.
# If the container is still running, you will need to use
#
#     *driver* ``rm --force`` *container_id*
#
# Removing Images
# ===============
# You can remove an old image using the command
#
#     *driver* ``rmi`` *name*
#
# For example, *name* could be
# ``dismod_at.base`` ,
# ``dismod_at.mixed`` , or
# ``dismod_at.image`` .
# You can keep the old image, under a different name, using the commands
#
# | |tab| *driver* ``tag`` *name* *different_name*
# | |tab| *driver* ``rmi`` *name*
#
# Dockerfile
# ==========
# The ``build`` syntax will create the file
# `Dockerfile <https://docs.docker.com/glossary/?term=Dockerfile>`_
# in the current working directory.
# If such a file already exists, it will need to be moved or deleted.
#
# Errors
# ======
#
# #. If you get the error message
#
#        ``Unable to fetch some archives`` , ``maybe run apt-get update`` ...
#
#    There may be an old OCI image result for ``apt-get update``
#    that is out of date.
#    You can list the images using the command ``OCI images`` .
#    Try removing an old image that corresponds to a previous
#    ``apt-get update`` and then re-run the
#    ``dock_dismod_at.sh build`` command.
#
# #. If you get the error message
#
#        ``Release file for`` *package* ``is not valid yet`` ...
#
#    You system clock may be out of date (reporting an old day or time).
#    Try fixing the system clock.
#
# Run New Container
# *****************
# Once ``dismod_at.image`` has been created, you use the
# *build_type* syntax to run dismod_at in a container.
#
# Removing Containers
# ===================
# The dismod_at container for a particular *user* will be named
# ``dismod_at.`` *user* .
# If such a container already exists,
# you will be prompted with the corresponding *container_id* .
# The command
#
#     *driver* ``rm`` *container_id*
#
# will remove the container.
# If the container is still running, you will need to use
#
#     *driver* ``rm --force`` *container_id*
#
# build_type
# ==========
# The *build_type* syntax will run the correspond
# :ref:`command-name` in the OCI image.
# The argument *build_type* must be either ``debug`` or
# ``release`` .
# The ``release`` version should be much faster.
# The ``debug`` version will do more extensive error checking.
#
# database
# ========
# The second argument *database* must be a dismod_at database
# in the current working directory.
# This the first argument to the corresponding dismod_at command.
#
# command
# =======
# The third argument *command* must be one of the dismod_at commands.
# This is the second argument in the corresponding dismod_at command.
# The rest of the arguments ... are
# the same as the corresponding arguments for the :ref:`command-name` .
#
# Other Arguments
# ===============
# The other arguments to ``dock_dismod_at.sh`` are the same as in the
# syntax for the :ref:`command-name` ,
# except that ``dismod_at`` or ``dismodat.py``
# have been replaced by ``dock_dismod_at.sh`` *build_type* .
#
# Debugging
# *********
# Some times an error occurs during the running of a container
# and you would like to go inside the container and execute commands.
# The following instructions are useful for this:
#
# Determine Container Id
# ======================
#
#     *driver* ``ps -a``
#
# If *driver* is podman, the following might work better
#
#     ``podman ps --all --storage``
#
# Start Container
# ===============
# If a container status is ``Exited`` , you can start it using:
#
#     ``driver`` *start* ``container_id``
#
# Run Container
# =============
# If a container status is ``Up`` , you can run it using:
#
#     *driver* ``exec -it`` *container_id* ``bash``
#
# You will be in the container until you ``exit``
# the ``bash`` shell that is run by the command above.
#
# Stop Container
# ==============
# If a container status is ``Up`` , you can stop it using:
#
#     ``driver`` *stop* ``container_id``
#
# {xrst_end dock_dismod_at.sh}
