.. _dock_dismod_at.sh-name:

!!!!!!!!!!!!!!!!!
dock_dismod_at.sh
!!!!!!!!!!!!!!!!!

xrst input file: ``bin/dock_dismod_at.sh``

.. meta::
   :keywords: dock_dismod_at.sh, install, and, run, dismod_at, in, a, docker, image

.. index:: dock_dismod_at.sh, install, and, run, dismod_at, in, a, docker, image

.. _dock_dismod_at.sh-title:

Install and Run dismod_at in a Docker Image
###########################################

.. meta::
   :keywords: syntax

.. index:: syntax

.. _dock_dismod_at.sh@Syntax:

Syntax
******

| ./ ``dock_dismod_at.sh image base``
| ./ ``dock_dismod_at.sh image mixed``
| ./ ``dock_dismod_at.sh image dismod_at``
| ./ ``dock_dismod_at.sh image at_cascade``
| ./ ``dock_dismod_at.sh`` *build_type* *database* *command*  ...

.. meta::
   :keywords: oci

.. index:: oci

.. _dock_dismod_at.sh@OCI:

OCI
***
Both docker and podman create Open Container Initiative
`OCI <https://opencontainers.org/>`_ images and containers.

.. meta::
   :keywords: driver

.. index:: driver

.. _dock_dismod_at.sh@OCI@driver:

driver
======
The *driver* program, determined by this setting, can be either
docker or podman:

.. literalinclude:: ../../bin/dock_dismod_at.sh
   :lines: 41-41
   :language: sh

Below we referee to the value of this shell variable as *driver* .

.. meta::
   :keywords: logging, output

.. index:: logging, output

.. _dock_dismod_at.sh@Logging Output:

Logging Output
**************
You can save the output of any of the commands above by redirecting
standard output and standard error to a file.
For example,

    ./ ``dock_dismod_at.sh image base >&`` *log_file*

will redirect standard output and standard error to *log_file* .
If you do this, you will not see the progress during execution.
If also want to monitor the progress, in another window use

    ``tail -f`` *log_file*

This ``tail`` command will not terminate until you enter
control-C in the window where it is running.

.. meta::
   :keywords: purpose

.. index:: purpose

.. _dock_dismod_at.sh@Purpose:

Purpose
*******
This bash script will create or run a dismod_at OCI image
and can be run from any directory.
Using this script is an  alternative to going through the steps required to
:ref:`install_dismod_at<install_unix-name>` .
You can use the following link to get a get a copy of the dismod_at.sh
`bash script <https://raw.githubusercontent.com/bradbell/dismod_at/master/bin/dock_dismod_at.sh>`_
If you understand docker, this script also serves as an example
install of dismod_at.

.. meta::
   :keywords: requirements

.. index:: requirements

.. _dock_dismod_at.sh@Requirements:

Requirements
************
You must have a copy of `docker <https://docs.docker.com/>`_, or
`podman <https://podman.io>`_
installed on your system.
You can test this on your system by trying to execute the following command:

    *driver* ``run busybox echo`` ``'Hello World'``

.. meta::
   :keywords: building, images

.. index:: building, images

.. _dock_dismod_at.sh@Building Images:

Building Images
***************
The image commands will not execute if the corresponding OCI image
already exists.
You must remove containers that use an image and then remove the image,
before you can execute the image command successfully.

.. meta::
   :keywords: dismod_at_version

.. index:: dismod_at_version

.. _dock_dismod_at.sh@Building Images@dismod_at_version:

dismod_at_version
=================
This script will build the following version of dismod_at image:

.. literalinclude:: ../../bin/dock_dismod_at.sh
   :lines: 95-96
   :language: sh

.. meta::
   :keywords: at_cascade_version

.. index:: at_cascade_version

.. _dock_dismod_at.sh@Building Images@at_cascade_version:

at_cascade_version
==================
This script can build the following version of the optional at_cascade image:

.. literalinclude:: ../../bin/dock_dismod_at.sh
   :lines: 105-106
   :language: sh

.. meta::
   :keywords: dismod_at.base

.. index:: dismod_at.base

.. _dock_dismod_at.sh@Building Images@dismod_at.base:

dismod_at.base
==============
The ``image base`` syntax creates a new OCI image with the name
``dismod_at.base`` .
The :ref:`whats_new<whats_new_2019-name>` instructions will tell you if
you need to re-execute this command.

.. meta::
   :keywords: dismod_at.mixed

.. index:: dismod_at.mixed

.. _dock_dismod_at.sh@Building Images@dismod_at.mixed:

dismod_at.mixed
===============
The ``image mixed`` syntax creates a new OCI image with the name
``dismod_at.mixed`` .
The ``dismod_at.base`` image must exist before the
``dismod_at.mixed`` image can be created.
The :ref:`whats_new<whats_new_2019-name>` instructions will tell you if
you need to re-execute this command.

.. meta::
   :keywords: dismod_at.image

.. index:: dismod_at.image

.. _dock_dismod_at.sh@Building Images@dismod_at.image:

dismod_at.image
===============
The ``image dismod_at`` syntax creates a new OCI image with the name
``dismod_at.image`` .
The ``dismod_at.mixed`` image must exist before the
``dismod_at.image`` image can be created.

.. meta::
   :keywords: at_cascade.image

.. index:: at_cascade.image

.. _dock_dismod_at.sh@Building Images@at_cascade.image:

at_cascade.image
================
The ``image at_cascade`` syntax creates a new OCI image with the name
``at_cascade.image`` .
The ``dismod_at.image`` image must exist before the
``at_cascade.image`` image can be created.
The `at_cascade <https://bradbell.github.io/at_cascade/doc/rst/at_cascade.html>`_ package is an optional add-on to the dismod_at program.

.. meta::
   :keywords: removing, containers

.. index:: removing, containers

.. _dock_dismod_at.sh@Building Images@Removing Containers:

Removing Containers
===================
If an existing container uses an image that is being created,
you will be prompted with the corresponding *container_id* .
The command

    *driver* ``rm`` *container_id*

will remove the container.
If the container is still running, you will need to use

    *driver* ``rm --force`` *container_id*

.. meta::
   :keywords: removing, images

.. index:: removing, images

.. _dock_dismod_at.sh@Building Images@Removing Images:

Removing Images
===============
You can remove an old image using the command

    *driver* ``rmi`` *name*

For example, *name* could be
``dismod_at.base`` ,
``dismod_at.mixed`` , or
``dismod_at.image`` .
You can keep the old image, under a different name, using the commands

| |tab| *driver* ``tag`` *name* *different_name*
| |tab| *driver* ``rmi`` *name*

.. meta::
   :keywords: dockerfile

.. index:: dockerfile

.. _dock_dismod_at.sh@Building Images@Dockerfile:

Dockerfile
==========
The ``build`` syntax will create the file
`Dockerfile <https://docs.docker.com/glossary/?term=Dockerfile>`_
in the current working directory.
If such a file already exists, it will need to be moved or deleted.

.. meta::
   :keywords: errors

.. index:: errors

.. _dock_dismod_at.sh@Building Images@Errors:

Errors
======

#. If you get the error message

       ``Unable to fetch some archives`` , ``maybe run apt-get update`` ...

   There may be an old OCI image result for ``apt-get update``
   that is out of date.
   You can list the images using the command ``OCI images`` .
   Try removing an old image that corresponds to a previous
   ``apt-get update`` and then re-run the
   ``dock_dismod_at.sh build`` command.

#. If you get the error message

       ``Release file for`` *package* ``is not valid yet`` ...

   You system clock may be out of date (reporting an old day or time).
   Try fixing the system clock.

.. meta::
   :keywords: run, new, container

.. index:: run, new, container

.. _dock_dismod_at.sh@Run New Container:

Run New Container
*****************
Once ``dismod_at.image`` has been created, you use the
*build_type* syntax to run dismod_at in a container.

.. meta::
   :keywords: removing, containers

.. index:: removing, containers

.. _dock_dismod_at.sh@Run New Container@Removing Containers:

Removing Containers
===================
The dismod_at container for a particular *user* will be named
``dismod_at.`` *user* .
If such a container already exists,
you will be prompted with the corresponding *container_id* .
The command

    *driver* ``rm`` *container_id*

will remove the container.
If the container is still running, you will need to use

    *driver* ``rm --force`` *container_id*

.. meta::
   :keywords: build_type

.. index:: build_type

.. _dock_dismod_at.sh@Run New Container@build_type:

build_type
==========
The *build_type* syntax will run the correspond
:ref:`command-name` in the OCI image.
The argument *build_type* must be either ``debug`` or
``release`` .
The ``release`` version should be much faster.
The ``debug`` version will do more extensive error checking.

.. meta::
   :keywords: database

.. index:: database

.. _dock_dismod_at.sh@Run New Container@database:

database
========
The second argument *database* must be a dismod_at database
in the current working directory.
This the first argument to the corresponding dismod_at command.

.. meta::
   :keywords: command

.. index:: command

.. _dock_dismod_at.sh@Run New Container@command:

command
=======
The third argument *command* must be one of the dismod_at commands.
This is the second argument in the corresponding dismod_at command.
The rest of the arguments ... are
the same as the corresponding arguments for the :ref:`command-name` .

.. meta::
   :keywords: other, arguments

.. index:: other, arguments

.. _dock_dismod_at.sh@Run New Container@Other Arguments:

Other Arguments
===============
The other arguments to ``dock_dismod_at.sh`` are the same as in the
syntax for the :ref:`command-name` ,
except that ``dismod_at`` or ``dismodat.py``
have been replaced by ``dock_dismod_at.sh`` *build_type* .

.. meta::
   :keywords: debugging

.. index:: debugging

.. _dock_dismod_at.sh@Debugging:

Debugging
*********
Some times an error occurs during the running of a container
and you would like to go inside the container and execute commands.
The following instructions are useful for this:

.. meta::
   :keywords: determine, container, id

.. index:: determine, container, id

.. _dock_dismod_at.sh@Debugging@Determine Container Id:

Determine Container Id
======================

    *driver* ``ps -a``

If *driver* is podman, the following might work better

    ``podman ps --all --storage``

.. meta::
   :keywords: start, container

.. index:: start, container

.. _dock_dismod_at.sh@Debugging@Start Container:

Start Container
===============
If a container status is ``Exited`` , you can start it using:

    ``driver`` *start* ``container_id``

.. meta::
   :keywords: run, container

.. index:: run, container

.. _dock_dismod_at.sh@Debugging@Run Container:

Run Container
=============
If a container status is ``Up`` , you can run it using:

    *driver* ``exec -it`` *container_id* ``bash``

You will be in the container until you ``exit``
the ``bash`` shell that is run by the command above.

.. meta::
   :keywords: stop, container

.. index:: stop, container

.. _dock_dismod_at.sh@Debugging@Stop Container:

Stop Container
==============
If a container status is ``Up`` , you can stop it using:

    ``driver`` *stop* ``container_id``
