$Id:$
-----------------------------------------------------------------------------
dismod_at: Estimating Disease Rates as Functions of Age and Time
          Copyright (C) 2014-19 University of Washington
             (Bradley M. Bell bradbell@uw.edu)

This program is distributed under the terms of the
	     GNU Affero General Public License version 3.0 or later
see http://www.gnu.org/licenses/agpl.txt
-----------------------------------------------------------------------------
$begin wish_list$$
$spell
	dev
	Dismod
	eigen
	optimizer
	cppad
	CppAD
	checkpointing
	pos
	Jacobian
	std
	avgint
	dage
	dtime
	var
	cv
	integrands
	nans
	csv
	mtother
	Covariate
	def
	args
	kwargs
	mu
	const
	smoothings
$$

$section Dismod_at Wish List$$

$head Asymptotic Statistics$$
The current version of the
$cref/asymptotic/sample_command/method/asymptotic/$$ statistics is very slow
and is not being used.
Perhaps we should use the method without including the constraint information
and see how well that works.

$head More Random Effects$$
Perhaps each covariate multiplier in the
$cref mulcov_table$$ should have an option to be a random effect.

$head Censored Laplace$$
The censored density formula for a Gaussian
$cref/G(y,mu,delta,c)
	/censor_density
	/Gaussian
	/Censored Density, G(y,mu,delta,c)
/$$
is correct even if $latex c > \mu$$.
On the other hand, the formula for the Laplace case
$cref/L(y,mu,delta,c)
	/censor_density
	/Laplace
	/Censored Density, L(y,mu,delta,c)
/$$
requires $latex c \leq \mu$$.
The Laplace case can be extended using the fact that it is symmetric,
integrating from $latex \mu$$ to $latex c$$,
using absolute values for the integration limits,
and the Sign function.
This will result in a non-smooth the optimization problem.
Perhaps the problem can be reformulated with auxillary variables
to be a smooth problem ?

$head create_database$$
Make a version of $cref create_database$$ that uses
keyword arguments and replaces the ones that are not present by
default values. This could be done using the prototype
$codei%
	def create_database(*%args%, **%kwargs%) :
%$$
where $icode args$$ are the positional arguments and
$icode kwargs$$ are the keyword arguments.
This would enable backward compatibility.

$head ODE Solution$$

$subhead Prevalence ODE$$
If $latex S$$ and $latex C$$ satisfy the dismod_at
$cref/ordinary differential equation
	/avg_integrand/Ordinary Differential Equation
/$$ then prevalence $latex P = C / (S + C)$$ satisfies
$latex \[
	P' = \iota  [ 1 - P ] - \rho P - \chi  [ 1 - P] P
\] $$
We can therefore solve for prevalence without other cause mortality
$latex \omega$$ or all cause mortality $latex \omega + \chi P$$.
$list number$$
The ODE for $latex P$$ is non-linear,
while the ODE is $latex (S, C)$$ is linear.
$lnext
All of the current integrands, except for
$cref/susceptible/avg_integrand/Integrand, I_i(a,t)/susceptible/$$ and
$cref/withC/avg_integrand/Integrand, I_i(a,t)/withC/$$
can be computed from $latex P$$ (given that the rates are inputs to the ODE).
$lnext
If we know all cause mortality $latex \alpha = \omega + \chi P$$,
once we have solved for $latex P$$,
we can compute $latex \omega = \alpha - \chi P$$.
Furthermore
$latex \[
	(S + C)' = - \alpha (S + C)
\] $$
So we can also compute $latex S + C$$, and
$latex C = P (S + C)$$,
$lnext
Given the original ODE, we know that the true solution for
$latex S$$, must be positive, and $latex C$$, $latex P$$ must be
non-negative.
Negative values for these quantities will correspond to
numerical precision errors in the solution of the ODE.
$lnext
One advantage of this approach,
over the current approach of solving the ODE in $latex (S, C)$$,
is that the solution is stable as $latex S + C \rightarrow 0$$.
(The current approach computes $latex P = C / (S + C)$$.
$lend

$subhead Large Excess Mortality$$
If case where $icode rate_case$$ is
$cref/iota_pos_rho_zero/option_table/rate_case/iota_pos_rho_zero/$$
corresponds to
$code dev::eigen_ode2::Method::Case Three$$ in the ODE solver.
If excess mortality $latex \chi$$ is unreasonably large,
this can result in exponential overflow and infinity or nan.
It is possible to redo the calculations in case three to properly
handle this condition.

$subhead Conditionals$$
It is now possible to use conditional expressions in the ODE solution
(CppAD this will now work properly these conditionals
and two levels of AD and revere mode).
This change would remove the need for the
$cref/rate_case/option_table/rate_case/$$ option.
Note that this will also work with checkpointing.

$subhead Checkpointing$$
It should greatly reduce memory if we use
CppAD checkpointing of an ODE that has been
extended to include derivatives with respect to parameters; see
$href%http://www.coin-or.org/CppAD/Doc/checkpoint_extended_ode.cpp.htm
	%checkpoint_extended_ode
%$$.

$head meas_std$$
Currently the data table
$cref/meas_std/data_table/meas_std/$$
must be specified (except for uniform density).
Perhaps we should allow for this standard deviation to be
$code null$$ in the case when the corresponding
$cref/meas_value/data_table/meas_value/$$ must not be zero
and the $cref/minimum_meas_cv/integrand_table/minimum_meas_cv/$$
would be used to determine the measurement accuracy.

$head Command Diagrams$$
It would be good to give a data flow diagram for each command
that corresponds to its inputs and outputs; i.e., to diagram
the information under the heading
$cref/inputs and outputs by command/data_flow/Input and Output by Command/$$.

$head Lagrange Multipliers$$
Change the Lagrange multipliers
$cref/lagrange_dage/fit_var_table/lagrange_dage/$$ (dtime) in the
fit_var table to be null when there is no corresponding age (time) different;
i.e., at the maximum age (time).


$head Documentation$$

$subhead Real World Example$$
It would be good to include a real world example.
Since this is an open source program, we would need a data set
that could be made distributed freely without any restriction on its use.

$subhead User Examples$$
The $cref user$$ examples before
$cref user_change_grid.py$$ have a discussion at the top of each example.
Add a discussion for the rest of the user examples.

$head Random Starting Point$$
Have an option to start at a random point from the prior for the fixed effects
(instead of the mean of the fixed effects).
This would better detect local minima and represent solution uncertainty.

$head Tracing Optimization$$
Add options to specify the file name for the optimizer trace
at both the fixed and random effects levels.

$head Windows Install$$
Make and test a set of Windows install instructions for $code dismod_at$$.

$end
